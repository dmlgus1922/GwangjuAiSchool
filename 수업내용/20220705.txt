벡터의 내적
x = np.array([[1,2]])
y = np.array([[1,2,3]]).T
y.dot(x) => 가능,  x.dot(y) => 불가능
x와 y의 shape을 확인해 가로 세로를 맞춰준다. 트랜스포즈를 이용..
벡터 연산은 자리를 바꾸면 결과가 바뀌거나 연산 자체가 안 될 수 있다.

곱연산은 스칼라 연산과 벡터 연산이 있다. 
스칼라 연산은 각각의 원소로 연산된다.
벡터연산은 내적이라 부르고 가로, 세로로 연산한다.

브로드캐스팅 연산
[[1,1,1],[1,1,1],[1,1,1]] + [1] => [[2,2,2],[2,2,2],[2,2,2]] 축을 늘려 같은 값으로 채운 후 연산을 수행한다.
[[1,2,3],[4,5,6],[7,8,9]] > [1,2,3]
=> [[1,2,3],[4,5,6],[7,8,9]] > [[1,2,3],[1,2,3],[1,2,3]] 
=> [[False, False, False], [ True,  True,  True], [ True,  True,  True]]

all 함수
배열 내부의 모든 값이 참일 때 True
any 함수
배열 내부의 하나의 값이라도 참일 때 True
ex)
x = numpy.array([1,2,3])
y = numpy.array([1])
numpy.all(x>y), numpy.any(x>y) => (False, True)

넘파이 안에 랜덤 모듈이 있다.
ex)
numpy.random.randint(0, 100, 10) => 0부터 99까지의 값 중 무작위 10개의 수로 이루어진 배열을 생성

where함수
배열이 불린형으로 이루어져 있을 때 참인 값들의 인덱스를 반환
ex)
x = np.array([4,5,6,7,3,2])
x > 5 => array([F,T,T,F,F])
np.where(x>5) => array([1,2], dtype = int64)
추가)
np.where(x>5, 10, 20) => array([20, 10, 10, 20, 20]) True일 때 10으로, False일 때 20으로 바꾸겠다.
값을 줄 때는 반드시 참값과 거짓값을 함께 부여해야 한다.

인덱스 정렬
x = np.array([3,4,5,1,2])
np.argsort(x) => array([3,4,0,1,2])

인덱스 반환
x = np.array([3,4,5,1,2])
np.argmax(x) => array([2])
np.argmin(x) => array([3])

불린 인덱스
배열에 있는 값을 반환할 특정 조건을 불린형의 배열에 넣어서 추출할 수 있다.
ex)
x = np.array([1,2,3,4,5])
cond = x>3
x[cond] => array([4,5])
x.shape => (5,) 기존의 배열에 영향을 주지 않는다.
 응용한 경우
x = np.array([3,4,5,1,2])
x[np.argsort()] => array([1,2,3,4,5])
 *넘파이 배열을 이용해 인덱싱하는 것이다. 불린 인덱스는 참값인 원소를 꺼낸다는 의미고 넘버 인덱스는 해당 인덱스의 원소를 꺼낸다는 뜻.
 때문에 불린 인덱스는 원소의 개수가 같아야 하고 넘버인덱스는 같지 않아도 해당 인덱스의 원소만 꺼내는 것이다.
 
팬시 인덱스
정수형 배열의 값을 사용하여 해당 정수의 인덱스에 위치한 값을 반환한다.
x = np.array([[1,4], [9,16]], int)
a = np.array([0,1,1,1,0,0], int)
b = np.array([0,0,0,1,1,1], int)
x[a,b] => array([1, 9, 9, 16, 4, 4])

------------------------------------------------------------------------------------------------------------------------

판다스
파이썬의 데이터 분석 라이브러리다. 데이터 테이블을 다루는 일종의 도구.
기본적으로 넘파이를 사용한다.
-데이터프레임: 데이터 테이블 전체 객체. 시리즈를 모아놓은 집합이라 볼 수 있다.
-시리즈: 각 열 데이터를 다루는 객체. 데이터 피처에 기반한 한 열의 객체.

시리즈 객체는 인덱스, 데이터, 데이터 타입으로 이루어져 있다.
 - 데이터: 값을 저장하는 요소
 - 인덱스: 0부터 시작, 숫자로만 할당. 
	시리즈 객체에는 숫자, 문자열, 0 이외의 값으로 시작하는 숫자, 순서가 일정하지 않은 숫자를 입력할 수도 있다. 
	또한 인덱스 값의 중복을 허용한다.
 - 데이터타입: 넘파이의 데이터 타입과 일치한다. 
	판다스는 넘파이의 래퍼 라이브러리이다. 넘파이의 모든 기능을 지원하고 데이터 타입도 그대로 적용한다.

넘파이와 마찬가지로 import를 해줘 사용한다. 보통 pd로 줄여 쓴다.

시리즈 객체를 만들기 위해 시리즈 클래스를 사용한다.
pd.Series(data = [구조로 된 데이터], index = [데이터 길이에 맞는 인덱스], dtype = 명시적으로 나타낼 데이터 타입)
pd.Series(딕셔너리) 형태로 시리즈 객체를 쉽게 만들 수도 있다.
 - 이 때, 인덱스를 추가적으로 명시한다면 딕셔너리보다 인덱스 길이가 짧을 때(그러나 인덱스와 딕셔너리의 키값이 같을 때) 인덱스에 해당하는 데이터만 입력된다.
	또한 인덱스가 더 길 때는 시리즈 객체의 데이터를 비워두고 인덱스 길이만큼 확장해 생성한다.
	인덱스가 딕셔너리가 가진 키값 외의 값만으로 명시되어 있다면 그 길이만큼 시리즈객체를 생성하고 데이터는 비어있는 형태가 된다.

데이터프레임 객체를 만들기 위해 데이터프레임 클래스를 사용한다.
df = pd.DataFrame(벨류값이 1차원 데이터인 딕셔너리)와 같은 방식으로 만들 수도 있다.
df['data'] = [1,2,3,4,5]와 같은 방식으로 'data'라는 열 이름을 가진 [1,2,3,4,5] 시리즈 객체를 추가한다. 단, 길이는 같아야 한다.

*데이터프레임의 데이터타입은 시리즈마다 다를 수 있다. 

df = pd.read_csv('파일.csv') => csv파일을 불러와 데이터프레임으로 읽을 수 있다.
df.head() => 데이터 인스턴스를 기본 5개, 명시하는 값만큼 가져온다.
df['데이터 피쳐(시리즈 이름)'] => 열 정보를 읽어준다.
df[:1] => 슬라이싱을 한다면 데이터 인스턴스를 추출한다.

loc메소드
ex)
df.loc[1, 'Name'] => 1인덱스의 'Name'열(시리즈명) 값을 불러온다.
loc메소드를 사용하지 않을 때는 df['Name'][1]과 같이 열(시리즈명), 인덱스 순으로 불러줘야 한다.

iloc메소드
인덱스, 시리즈를 상대주소화, 정수인덱스화 한다. 
ex) df.iloc[0,0] => 해당 위치의 원소를 추출함. 인덱스, 시리즈명 순으로 입력. 
	df.iloc[0:2,0:5:2] => 슬라이싱처럼 사용도 가능함.

reset_index
df.reset_index() => 인덱스를 순서대로 다시 적용해준다.
df.reset_index(drop = True)  => 기존의 인덱스를 지워주며 인덱스를 새로 적용하는 것.

drop
df.drop(columns = '시리즈명') 해당 시리즈를 지워줄 때 사용한다.
df.drop(columns = ['시리즈명1', '시리즈명2'])처럼 여러개를 지울 수도 있다.
df.drop(index = '인덱스명') 인덱스에 해당하는 데이터 인스턴스를 지워줄 때 사용한다.

groupby
df.groupby('기준')['적용열']  => 기준이 되는 이산형 데이터, 각 항목에 해당하는 값을 분류함.
	분류된 데이터로 sum, mean, count 등 연산이 가능하다.

merge
SQL의 join과 유사하다.
pd.merge(left = df_l, right = df_r, how='병합 방법', on = '기준 열')
병합방법
- inner: 내부 join. 교집합
- left: 왼쪽 데이터테이블을 기준으로 병합.
- right: 오른쪽 데이터테이블을 기준으로 병합.
- outer: full join. 합집합.
병합되는 테이블에서 기준이 되는 열에 해당하는 값이 없을 때 NaN으로 채워진다.
각 테이블이 가지고 있는 피쳐의 이름이 같으면 피쳐의 이름도 구분되어 병합된다.

concat
pd.concat([데이터프레임1, 데이터프레임2]) => 축을 기준으로 붙여버린다. 기본axis = 0
	축이 0이면 데이터 인스턴스 개수가 늘어남. 피쳐의 개수를 맞추는 것
	축이 1이면 피쳐가 늘어남. 데이터인스턴스 개수를 맞추는 것
	기준만 맞는다면 여러개를 결합할 수 있음.

append
df_1.append(df_2)의 형태로 사용. 인스턴스를 추가할 때 잘 쓰인다. 하나씩만 추가 가능.